<html>

<head>
  <!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.6.0/font/bootstrap-icons.css"> -->

  <!-- <meta name="viewport" content="width=device-width, 
        initial-scale=1.0, 
        user-scalable=yes" /> -->
  <title>Visual Version Control for Processing</title>
  <meta charset="utf-8" />
  <style>
    #container {
      overflow: hidden;
      margin: 0px;
      border: 1px solid grey;
    }
  </style>
</head>

<body>

  <div id="container"></div>

  <script src="https://d3js.org/d3.v4.min.js"></script>
  <script src="https://unpkg.com/konva@8/konva.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js"></script>
  <script src="VFCANetworking.js"></script>
  <script src="GraphOperations.js"></script>
  <script src="konvaDrawing.js"></script>
  <script>

document.addEventListener('keypress', logKey);

function logKey(e) {
  savePositions()
}



    //D3 --------------------------
    var baseNodes = [];
    var baseLinks = [];
    var nodes = [...baseNodes]
    var links = [...baseLinks]

    var selectedId = -1

    function isNeighborLink(node, link) {
      return link.target.id === node.id || link.source.id === node.id
    }

    function getLinkColor(node, link) {
      return isNeighborLink(node, link) ? '#E5E5E5' : '#E5E5E5'
    }

    function getTextColor(node) {
      return node.id == selectedId ? 'green' : 'black'
    }

    var width = window.innerWidth
    var height = window.innerHeight

    var canvasWidth = width * 10
    var canvasHeight = height * 10
    var radius = 20

    var svg = d3.select('svg')
    svg.attr('width', canvasWidth).attr('height', canvasHeight)

    var linkElements,
      nodeElements,
      textElements

    // we use svg groups to logically group the elements together
    var linkGroup = svg.append('g').attr('class', 'links')
    var nodeGroup = svg.append('g').attr('class', 'nodes')
    var textGroup = svg.append('g').attr('class', 'texts')

    // simulation setup with all forces
    var linkForce = d3
      .forceLink()
      .id(link => link.id)
      .strength(link => link.strength)
      .distance(30)

    var simulation = d3
      .forceSimulation()
      .force('link', linkForce)
      .force('charge', d3.forceManyBody().strength(-100))
      .force('center', d3.forceCenter(width / 2, height / 2))
      .force('collision', d3.forceCollide().radius(60))
      .velocityDecay(.90)
      .alphaTarget(.01);


    var dragDrop = d3.drag().on('start', function (node) {
      node.fx = node.x
      node.fy = node.y
    }).on('drag', function (node) {
      //simulation.alphaTarget(.01)
      node.fx = d3.event.x
      node.fy = d3.event.y
    }).on('end', function (node) {
      if (!d3.event.active) {
        //simulation.alphaTarget(.01)
      }
      node.fx = null
      node.fy = null
    })


    function savePositions() {
      console.log("saving positions!")
      var positions = {};

      for (i = 0; i < nodes.length; i++) {
        var n = nodes[i];
        var node = {
          "id": n.id,
          "x": n.x,
          "y": n.y
        }
        positions[n.id] = node;
      }
      console.log(positions)
      updatePositionData(request, positions);

    }




    function updateGraph() {
      // links
      linkElements = linkGroup.selectAll('line')
        .data(links, function (link) {
          return link.target.id + link.source.id
        })

      linkElements.exit().remove()

      var linkEnter = linkElements
        .enter().append('line')
        .attr('stroke-width', 3)
        .attr('stroke', 'rgba(50, 50, 50, 0.2)')

      linkElements = linkEnter.merge(linkElements)

      // nodes
      nodeElements = nodeGroup.selectAll('.node')
        .data(nodes, function (node) { return node.id })

      var nodeEnter = nodeElements
        .enter()
        .append("svg:image")
        .attr("class", "node")
        .attr("height", 40)
        .attr("width", 40)
        .attr("x", function (d) { return -25; })
        .attr("y", function (d) { return -25; })
        .call(dragDrop)
        .on('click', selectNode)
        .on('dblclick', doubleClicked)

      //nodeElements.transition().duration(1).attr("xlink:href",  function(node) {return getIconImage(node)});

      nodeElements.exit().remove()

      nodeElements = nodeElements.merge(nodeEnter)


      // texts
      textElements = textGroup.selectAll('text')
        .data(nodes, function (node) { return node.id })

      textElements.exit().remove()

      var textEnter = textElements
        .enter()
        .append('text')
        .text(function (node) { return node.label })
        .attr('font-size', 15)
        .attr('dx', 15)
        .attr('dy', 4)
        .on('dblclick', function (node) {
          var result = prompt('Rename Node', node.label);
          if (result) {
            node.label = result;
            // https://stackoverflow.com/questions/22951182/how-to-rename-a-node-in-d3-graph
          }
        })

      textElements = textEnter.merge(textElements)
    }

    function doubleClicked(selectedNode) {
      selectedId = -1
      sendFork(selectedNode.id).then(function (id) {
        console.log(id)
        selectedId = id
      }); //Java Side already selects new child as active version after fork
    }

    function updateSimulation() {
      updateGraph()
      //https://stackoverflow.com/questions/18206231/saving-and-reloading-a-force-layout-using-d3-js
      simulation.nodes(nodes).on('tick', () => {
        nodeElements
          .attr('cx', function (node) { return node.x = Math.max(radius, Math.min(canvasWidth - radius, node.x)); })
          .attr('cy', function (node) { return node.y = Math.max(radius, Math.min(canvasHeight - radius, node.y)); })
          .attr("transform", function (node) {
            return "translate(" +
              Math.max(radius, Math.min(canvasWidth - radius, node.x)) + "," +
              Math.max(radius, Math.min(canvasHeight - radius, node.y)) + ")";
          })
        textElements
          .attr('x', function (node) { return node.x })
          .attr('y', function (node) { return node.y })
        linkElements
          .attr('x1', function (link) { return link.source.x })
          .attr('y1', function (link) { return link.source.y })
          .attr('x2', function (link) { return link.target.x })
          .attr('y2', function (link) { return link.target.y })
      })

      simulation.force('link').links(links)
    }

    var runOnceOnDataLoad = false
    function updateData() { 
      requestData(request);
      //savePositions(); //TODO
      if (data != null) {
        if (!runOnceOnDataLoad) {
          requestCurrentId(request).then(function (id) {
            selectedId = id
            runOnceOnDataLoad = true
          });
          restorePositions(); //TODO
        }
        if(_.isEqual(oldData,data)){
          console.log('same')
        }else{
          console.log('different')
        }
      
        nodes = updateNodes(data[0], nodes)
        links = updateLinks(data[1], nodes)
        
        //document.getElementById("testText").innerHTML = "Loaded";
      }
      updateSelectedIconImage()
    }

    function graphicsUpdate() {
      updateSimulation();
      konvaUpdate(nodes, links);
      konvaDrawLayer();
      setTimeout(graphicsUpdate, 10)
    }

    function dataLoop() {
      updateData()
      setTimeout(dataLoop, 500)
    }

    konvaInit();
  
    dataLoop();
    graphicsUpdate();


  </script>
</body>

</html>